<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>FluidSim - Real-Time Fluid Simulation</title>
  <link rel="stylesheet" href="styles.css" />
  <style>
    /* Basic styles for canvas and controls */
    #webglCanvas {
      border: 1px solid #333;
    }
    #ui {
      margin-top: 10px;
    }
    #ui button {
      margin-right: 5px;
    }
  </style>
</head>
<body>
  <!-- Header -->
  <header>
    <div class="container">
      <h1>FluidSim</h1>
      <p>Experience the power of real-time fluid dynamics simulation. Built with cutting-edge WebGL2 and transform feedback.</p>
    </div>
  </header>
  <!-- Hero Section -->
  <section class="hero container">
    <a href="#simulation" class="cta-button" id="launchButton">Launch Simulation</a>
  </section>
  <!-- Features Section -->
  <section class="features container">
    <div class="feature-card">
      <h3>Real-Time Physics</h3>
      <p>Powered by advanced SPH (Smoothed Particle Hydrodynamics) algorithms for realistic fluid behavior.</p>
    </div>
    <div class="feature-card">
      <h3>Interactive Tools</h3>
      <p>Create, manipulate, and experiment with fluids using intuitive tools like water, wind, and erasers.</p>
    </div>
    <div class="feature-card">
      <h3>Customizable Parameters</h3>
      <p>Adjust viscosity, surface tension, and more to see how fluids behave under different conditions.</p>
    </div>
  </section>
  <!-- Simulation Section -->
  <section id="simulation" class="simulation-section">
    <div class="container">
      <h2>Fluid Simulation</h2>
      <p>Interact with the simulation below.</p>
      <div class="canvas-container">
        <canvas id="webglCanvas" width="800" height="600"></canvas> <!-- Fixed canvas ID -->
        <canvas id="overlayCanvas" width="800" height="600"></canvas> <!-- 2D canvas for brush drawing -->
      </div>
      
      <div id="controls" class="control-panel">
        <div class="control-group">
          <button id="waterToolBtn" data-tool="water" class="tool-btn">Water Tool</button>
          <button id="windToolBtn" data-tool="wind" class="tool-btn">Wind Tool</button>
          <button id="eraseWaterBtn" data-tool="eraseWater" class="tool-btn">Erase Water</button>
          <button id="eraseWindBtn" data-tool="eraseWind" class="tool-btn">Erase Wind</button>
        </div>
        <div class="control-group">
          <label for="brushSize">Brush Size</label>
          <input type="range" id="brushSize" min="10" max="100" value="50">
        </div>
        <div class="control-group">
          <label for="brushStrength">Brush Strength</label>
          <input type="range" id="brushStrength" min="1" max="200" value="100">
        </div>
        <div class="control-group">
          <label>Particle Count: <span id="particleCount">0</span></label>
        </div>
        <div class="control-group">
          <label>Viscosity: <span id="viscosityValue">0.01</span></label>
          <input type="range" id="viscosity" min="0" max="0.1" step="0.001" value="0.01">
        </div>
        <div class="control-group">
          <label>Surface Tension: <span id="surfaceTensionValue">0.0728</span></label>
          <input type="range" id="surfaceTension" min="0" max="0.2" step="0.001" value="0.0728">
        </div>
        <div class="control-group">
          <button id="resetBtn">ðŸ”„ Reset Simulation</button>
        </div>
      </div>
    </div>
  </section>
  <!-- Footer -->
  <footer>
    <div class="container">
      <p>&copy; 2025 FluidSim. All rights reserved. Built By William Joffe.</p>
    </div>
  </footer>
  <!-- Shaders -->
  <script id="vertex-shader" type="x-shader/x-vertex">
    attribute vec2 a_position;
    uniform vec2 u_resolution;
    uniform float u_pointSize;
    void main() {
      // Convert the particle positions to normalized coordinates.
      vec2 normalizedPosition = (a_position / u_resolution) * 2.0 - 1.0;
      gl_Position = vec4(normalizedPosition, 0.0, 1.0);
      gl_PointSize = u_pointSize; // Set the point size of the particles.
    }
  </script>
  <script id="fragment-shader" type="x-shader/x-fragment">
    precision mediump float;
    void main() {
      // Calculate distance from the center of the point sprite.
      vec2 center = gl_PointCoord - vec2(0.5);
      float r = length(center);
      
      // Each particle contributes a weight that falls off exponentially.
      // Adjust the coefficient (here 10.0) to control how "soft" and far-reaching the blob is.
      float intensity = exp(-10.0 * r * r);
      
      // Use smoothstep for a soft threshold that creates a clean boundary when particles merge.
      float alpha = smoothstep(0.2, 0.5, intensity);
      
      // Create a gradient between a deep blue and a light blue,
      // modulated by the intensity, so that overlapping particles form a continuous body.
      vec3 deepBlue = vec3(0.0, 0.2, 0.5);
      vec3 lightBlue = vec3(0.2, 0.6, 1.0);
      vec3 color = mix(deepBlue, lightBlue, intensity);
      
      gl_FragColor = vec4(color, alpha);
    }
  </script>
  <!-- New: Simulation Update Shader for Transform Feedback -->
  <script id="update-shader" type="x-shader/x-vertex">#version 300 es
precision highp float;

in vec2 a_position;
in vec2 a_velocity;
uniform float u_dt;
uniform vec2 u_gravity;
uniform sampler2D u_positions;
uniform int u_particleCount;
out vec2 v_position;
out vec2 v_velocity;

// Adjusted physics constants for better stacking and cohesion
const float PI = 3.141592653589793;
const float MASS = 1.0;
const float REST_DENSITY = 100.0;        // Increased for more stable pressure
const float GAS_CONSTANT = 2000.0;       // Increased for stronger repulsion
const float VISCOSITY = 500.0;           // Increased for more cohesion
const float H = 25.0;                    // Increased interaction radius
const float HSQ = H * H;
const float POLY6 = 315.0 / (64.0 * PI * pow(H, 9.0));
const float SPIKY_GRAD = -45.0 / (PI * pow(H, 6.0));
const float VISC_LAP = 45.0 / (PI * pow(H, 6.0));
const float DAMPING = 0.98;
const float BOUNDARY_DAMPING = 0.7;

// SPH Kernel functions
float kernelPoly6(float rSquared) {
    return rSquared > HSQ ? 0.0 : POLY6 * pow(HSQ - rSquared, 3.0);
}

vec2 kernelSpiky(vec2 r, float rlen) {
    return rlen > H ? vec2(0.0) : r * SPIKY_GRAD * pow(H - rlen, 2.0) / rlen;
}

float kernelViscosity(float rlen) {
    return rlen > H ? 0.0 : VISC_LAP * (H - rlen);
}

void main() {
    vec2 pos = a_position;
    vec2 vel = a_velocity;
    
    // Calculate particle density and pressure
    float density = 0.0;
    vec2 pressureForce = vec2(0.0);
    vec2 viscosityForce = vec2(0.0);
    
    // First pass: compute density
    for(int i = 0; i < u_particleCount; i++) {
        vec2 pos_j = texelFetch(u_positions, ivec2(i, 0), 0).xy;
        vec2 r = pos - pos_j;
        float rSquared = dot(r, r);
        
        if(rSquared < HSQ && rSquared > 0.01) {
            density += MASS * kernelPoly6(rSquared);
        }
    }
    
    // Prevent division by zero
    density = max(density, REST_DENSITY * 0.1);
    
    // Compute pressure
    float pressure = GAS_CONSTANT * (density - REST_DENSITY);
    
    // Second pass: compute forces
    for(int i = 0; i < u_particleCount; i++) {
        vec2 pos_j = texelFetch(u_positions, ivec2(i, 0), 0).xy;
        vec2 r = pos - pos_j;
        float rSquared = dot(r, r);
        
        if(rSquared < HSQ && rSquared > 0.01) {
            float rlen = sqrt(rSquared);
            
            // Pressure force - use kernelSpiky for gradient
            float pressure_j = GAS_CONSTANT * (density - REST_DENSITY);
            vec2 gradW = kernelSpiky(r, rlen);
            pressureForce += -gradW * MASS * (pressure + pressure_j) / (2.0 * density);
            
            // Viscosity force - use kernelViscosity for laplacian
            vec2 vel_j = texelFetch(u_positions, ivec2(i + u_particleCount, 0), 0).xy;
            viscosityForce += VISCOSITY * MASS * (vel_j - vel) * kernelViscosity(rlen) / density;
        }
    }
    
    // Update velocity and position
    vec2 acceleration = vec2(0.0, -500.0) + (pressureForce + viscosityForce) / density;
    vec2 newVelocity = vel + acceleration * u_dt;
    newVelocity *= DAMPING;
    
    vec2 newPosition = pos + newVelocity * u_dt;
    
    // Boundary conditions
    const float MARGIN = 5.0;
    if(newPosition.x < MARGIN) {
        newPosition.x = MARGIN;
        newVelocity.x = -newVelocity.x * BOUNDARY_DAMPING;
    }
    if(newPosition.x > 800.0 - MARGIN) {
        newPosition.x = 800.0 - MARGIN;
        newVelocity.x = -newVelocity.x * BOUNDARY_DAMPING;
    }
    if(newPosition.y < MARGIN) {
        newPosition.y = MARGIN;
        newVelocity.y = -newVelocity.y * BOUNDARY_DAMPING;
    }
    if(newPosition.y > 600.0 - MARGIN) {
        newPosition.y = 600.0 - MARGIN;
        newVelocity.y = -newVelocity.y * BOUNDARY_DAMPING;
    }
    
    v_position = newPosition;
    v_velocity = newVelocity;
}
</script>
  
  <!-- Scripts -->
  <script type="module" src="./scripts/ShaderUtils.js"></script>
  <script type="module" src="./scripts/Vector2.js"></script>
  <script type="module" src="./scripts/WindField.js"></script>
  <!-- Note: Remove older SPHSystem.js, FluidRenderer.js, InteractionManager.js if no longer used -->
  <script type="module" src="./scripts/FluidSimulation.js"></script>
  <script type="module" src="./scripts/UIControls.js"></script>
  <script type="module">
    import { FluidSimulation } from './scripts/FluidSimulation.js';
    import { UIControls } from './scripts/UIControls.js';
    const canvas = document.getElementById('webglCanvas');
    const fluidSimulation = new FluidSimulation(canvas);
    new UIControls(fluidSimulation, canvas);
  </script>
</body>
</html>
